IOSession用来对SocketChannel的读写操作进行统一管理的对象，一般作为SelectionKey的附件进行挂载。
保证每一个SocketChannel（代表一个网络连接）对象唯一对应（跨Selector不计在内）一个IOSession对象。

Session本意会话，是在网络连接上一层的抽象，Session内部一般都维护一些通讯的状态，典型的如HttpSession。

特别声明：一般事务相关的功能全部依附与Session内。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Session封装了一个客户端到服务器的一个网络连接。
其中包含具体的IO事件逻辑，内部可能持有过滤器链和处理器对象来完成数据的编码/解码与业务处理操作等。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
NIO Reactor模式下的Session的读写数据的具体方法逻辑！

Session中内部主要持有的对象以及作用？
Poller：在构造Session时传入，用来获取IO资源等信息。
Selector：由Poller获取，主要通过该对象获取key对应的信道对象，来完成具体的读写操作。
Executor：由Poller获取，Session的读写操作将由Executor来调度执行。
SelectionKey：事件源对象，Session对象主要挂载该key上，key中包含了具体IO事件的描述信息。
Channel：信道对象，由key获得。 数据读写的主要实体。
ByteBuffer： 数据读写的缓冲区。
以上对象是Session中处理数据读写的io级别的基础设施。
*******************************************************************************************************
FilterChain：过滤器链，对读取/写出的数据进行过滤操作的一个过滤器链表。其中典型的过滤器就是数据的编码解码器。
Handler：业务处理器。获取数据的主要业务处理方法。
FilterChain与Handler是Session中处理数据的业务层基础设施。
-------------------------------------------------------------------------------------------------------
Session的读数据操作！！特别注意，如何保证读取数据的完整性？
数据的读取操作将由Executor去执行。


Session的写数据操作！！
读取的数据经过业务处理以后返回，作为 响应写出。