问：IO 同步/异步  阻塞/非阻塞 的区别？
答：按照《Unix网络编程》的划分，IO模型可以分为：阻塞IO、非阻塞IO、IO复用、信号驱动IO和异步IO，
	按照POSIX标准来划分只分为两类：同 步IO和异步IO。
	如何区分呢？
	首先一个IO操作其实分成了两个步骤：发起IO请求和实际的IO操作，同步IO和异步IO的区别就在于第二个步骤是否阻塞，
	如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，
	如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。
	阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。
	
	注：此处（所说的第二步）实际IO操作，是指将内核（内核态）数据拷贝到应用进程地址空间（用户态）中的操作。★
	注：此处（所说的第一步）发起IO请求，是指应用进程进行IO调用，如果阻塞直到数据完全拷贝到当前进程空间中，则为阻塞IO。★
		如果调用立即返回，不阻塞当前进程，则为非阻塞IO。非阻塞IO时，一般采用状态事件+回调来进行实际的IO操作。★
		如果是同步IO，则状态事件为读写就绪。此时的数据仍在内核态中，但是已经准备就绪，可以进行读写操作。
		如果是异步IO，则状态事件为读写完成。此时的数据已经存在于应用进程的地址空间（用户态）中。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
问：TCP协议中如何保证数据的顺序与完整性？(TCP协议如何保证其可靠性？)
答：TCP协议工作在OSI的传输层，是一种可靠的面向链接的数据流协议。
    1. TCP之所以可靠，是因为它保证了传送数据包的顺序。
 	约定：约定通信双方为: 发送方(请求包) ----------> 接收方(响应包) |其中请求包与响应包均为TCP数据包
          顺序是用一个序列号来保证的，请求包中包含一个序列号，并且包含该数据包中的数据长度。
	响应包通过确认号来对这个请求包进行确认。响应包中的确认号表示已成功接受了请求包中的数据，
	并表示接受方已经准备好接收序列号为该确认号的请求包。
	注意：tcp的syn，ack等标识与SEQ序列号，ACK确认号要区别对待！
	2.TCP传送一个数据包时，它会把这个数据包放入重发队列中，同时启动计时器，如果收到了关于这个数据包的确认信息，
	便将此数据包从队列中删除，如果在计时器超时的时候仍然没有收到确认信息，则需要重新发送该数据包。
	3.另外，TCP通过数据分段中序列号来保证所有传输的数据可以按照正常的顺序进行重组，从而保证数据传输的完整性。
	
	综述：TCP通过1，确认机制 2，超时重传 3，基于序列号的数据重组来保证其自身的可靠性。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
问：RST标识的数据包什么情况下会出现？
答：在TCP协议中，RST标识复位，用来异常的关闭链接。
          在TCP的设计中它是不可或缺的，发送RST包关闭链接时，不必等缓冲区的数据都发送出去。
          直接丢弃缓冲区中的数据，发送RST包。
          而接受段收到RST包后，也不必发送ACK包来确认。
	产生RST包的一些原因：
	1，请求的目标端口为打开，服务端发送RST包。
	2，请求超时
	3，Socket内核接受缓冲区Recv-Q中的数据为完全被应用程序读取，而关闭该Socket。
	4，在向已关闭的Socket中发送数据。
		①如果调用close()方法，关闭的Socket代表的链接依然处于FIN_WAIT2状态，则正常返回ACK确认包。
		②如果状态FIN_WAIT2的超时，则close()调用后，依然会返回RST包。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
问：TCP链接中TIME_WAIT的具体含义？
答：主动关闭的Socket端会进入TIME_WAIT状态，并且持续2MSL时间长度，MSL就是maximum segment lifetime(最大分节生命期），
 	这是一个IP数据包能在互联网上生存的最长时间，超过这个时间将在网络中消失。
	MSL在RFC 1122上建议是2分钟，而源自berkeley的TCP实现传统上使用30秒，因而，TIME_WAIT状态一般维持在1-4分钟。
	TIME_WAIT状态存在的理由：
	1）可靠地实现TCP全双工连接的终止
 		在进行关闭连接四路握手协议时，最后的ACK是由主动关闭端发出的，
	 	如果这个最终的ACK丢失，服务器将重发最终的FIN，因此客户端必须维护状态信息允 许它重发最终的ACK。
	 	如果不维持这个状态信息，那么客户端将响应RST分节，服务器将此分节解释成一个错误（在java中会抛出connection reset的SocketException)。
		因而，要实现TCP全双工连接的正常终止，必须处理终止序列四个分节中任何一个分节的丢失情况，主动关闭 的客户端必须维持状态信息进入TIME_WAIT状态。
	2）允许老的重复分节在网络中消逝 
	    TCP分节可能由于路由器异常而“迷途”，在迷途期间，
        TCP发送端可能因确认超时而重发这个分节，迷途的分节在路由器修复后也会被送到最终目的地，
       	 这个 原来的迷途分节就称为lost duplicate。
  		在关闭一个TCP连接后，马上又重新建立起一个相同的IP地址和端口之间的TCP连接，
   		后一个连接被称为前一个连接的化身 （incarnation)，那么有可能出现这种情况，前一个连接的迷途重复分组在前一个连接终止后出现，从而被误解成从属于新的化身。
   		为了避免这个情 况，TCP不允许处于TIME_WAIT状态的连接启动一个新的化身，因为TIME_WAIT状态持续2MSL，
    	就可以保证当成功建立一个TCP连接的时 候，来自连接先前化身的重复分组已经在网络中消逝。
	新的SCTP协议通过在消息头部添加验证标志避免了TIME_WAIT状态。
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
问：Socket.listen()系统调用中，backlog参数的含义与作用？
答：内核为监听套接字创建了两个队列，未完成连接队列（SYN_RECV状态的连接）与已完成连接队列（ESTABLISHED状态的连接）。
	其总和不得超过backlog值， 控制该值的内核参数为net.core.somaxconn。
	accept()系统调用只是从已完成连接队列中弹出一个连接操作。
	connect()系统调用的连接如果完成了三次握手，则处在已完成连接队列中，只有服务端  accept()返回了该客户端的连接，此前connect()调用一直阻塞。